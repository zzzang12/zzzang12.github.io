---
title: 근묵자흑
date: 2020-08-27
categories: algorithm
---

근묵자흑이라는 말이 있다. "검은 먹을 가까이 하면 검어진다". 이는 좋지 못한 사람과 가까이 하면 악에 물들게 된다고 해석할 수 있다. 이는 사람 뿐만 아니라 숫자도 마찬가지이다. 여러 숫자들을 한 곳에 모아두면 시간이 흘러 모든 숫자가 그 중 가장 작은 수에 맞춰 변하게 된다.

현재 1부터 N까지의 정수가 한 번씩 등장하는 길이 N의 수열이 있다. 여기서 당신은 연속된 K개의 정수를 골라서 한 곳에 잠시 모아둘 수 있다. 시간이 지나면 당신이 고른 K개의 정수들은 K개 중 가장 작은 정수가 된다. 이 시간은 고려하지 않는다. 여기서 이 수열을 모두 같은 수로 만들고자 할 때 최소 몇 번 골라야 하는지 구하는 프로그램을 작성하시오.

예를 들어 4개의 수가 [2, 3, 1, 4]와 같이 있고 K=3일 때, [2, 3, 1, 4]을 고르게 되면 세 수는 2, 3, 1 중 가장 작은 수인 1로 변하게 된다. 이후 [1, 1, 1, 4]가 된다. 아직 4가 남아있으니 [1, 1, 1, 4]를 고르게 되면 [1, 1, 1, 1]이 되고 총 2번만에 모두 같은 수로 만드는 데 성공이다.

# 입력 형식

첫 줄에 공백으로 구분된 두 정수 N, K가 차례로 주어진다.
* N은 수열의 길이를 나타내는 2 이상 10만 이하의 자연수다.
* K는 한 번에 연속적으로 골라야 하는 정수의 개수를 나타내는 2 이상 N 이하의 자연수다.

두 번째 줄에는 공백으로 구분된 N개의 정수가 주어진다.
* 각 정수는 1부터 N까지의 정수 중 하나이며, 같은 정수가 두 번 이상 나타나지 않는다.

# 출력 형식

주어진 수열을 모두 같은 수로 만들고자 할 때 골라야 하는 최소 횟수를 출력한다.

### 예시 1

입력

```
4 3
2 3 1 4
```

출력

```
2
```

### 예시 2

입력

```
8 3
7 3 1 8 4 6 2 5
```

출력

```
4
```

### 예시 3

입력

```
37 4
31 36 20 30 1 9 6 13 3 29 11 25 7 8 2 24 34 18 26 15 23 28 37 19 21 4 32 14 16 10 12 27 22 35 5 17 33
```

출력

```
12
```

# 풀이

```
#include <stdio.h>
#include <stdlib.h>

int main() {
	int N, K;
	int *arr;
	int count;

	scanf("%d %d", &N, &K);
	arr = (int *)malloc(N * sizeof(int));
	for (int i = 0; i < N; i++)
		scanf("%d", &arr[i]);

	for (count = 0; N > K; count++)
		N -= (K - 1);
	count++;
	
	printf("%d", count);
	return 0;
}
```

K개의 원소가 있는 집합을 최대한 겹치지 않게 연결한다고 생각하자. 그럴려면 두 집합에서 공통인 하나의 원소만 연결하면 된다.
1. 하나는 겹쳐야 하므로 N에서 (K - 1)을 빼나간다.
2. 이것을 N이 K보다 작거나 같아질 때까지 반복한다.
3. 마지막 남은 N은 여러개가 겹치더라도 연결해야 하므로 count를 하나 증가시킨다.

하지만 뺄셈의 반복은 N이 커지면 연산량이 늘어나므로 나눗셈으로도 풀어보았다.

```
#include <stdio.h>
#include <stdlib.h>

int main() {
	int N, K;
	int *arr;
	int count;
	
	scanf("%d %d", &N, &K);
	arr = (int *)malloc(N * sizeof(int));
	for (int i = 0; i < N; i++)
		scanf("%d", &arr[i]);
	
	count = (N - K) / (K - 1) + 1;
	if ((N - K) % (K - 1))
		count++;
	
	printf("%d", count);
	return 0;
}
```

1. 처음 N개에서 K개만큼 빼고 count에 1을 더한다.
2. 겹치는 1개를 제외한 개수만큼 나눈다.
3. 이때 남는 원소가 있으면 count를 하나 증가시킨다.
